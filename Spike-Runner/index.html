<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spikes-Runner</title>
<style>
html, body { margin:0; background:#000; overflow:hidden; } /* MY FIRST 2D GAME I HOPE YOU LIKE */
canvas { display:block; }
.ui {
  position:fixed;
  bottom:10px;
  left:50%;
  transform:translateX(-50%);
  color:#aaa;
  font-family:monospace;
  text-align:center;
}
.banner {
  position:fixed;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  color:#fff;
  font-family:monospace;
  background:rgba(0,0,0,0.4);
  padding:8px 12px;
  border:1px solid rgba(255,255,255,0.2);
}
.portalText {
  position:fixed;
  top:56px;
  left:50%;
  transform:translateX(-50%);
  color:#0ff;
  font-family:monospace;
  background:rgba(0,15,15,0.5);
  padding:6px 10px;
  border:1px solid rgba(0,255,255,0.25);
  display:none;





}
</style>
<head>
<meta charset="UTF-8">
<title>Spikes-Runner</title>

<style>
html, body {
  margin:0;
  background:#000;
  overflow:hidden;
}
canvas { display:block; }

.ui {
  position:fixed;
  bottom:10px;
  left:50%;
  transform:translateX(-50%);
  color:#aaa;
  font-family:monospace;
  text-align:center;
}

.banner {
  position:fixed;
  top:18px;
  left:50%;
  transform:translateX(-50%);
  color:#fff;
  font-family:monospace;
  background:rgba(0,0,0,0.4);
  padding:8px 12px;
  border:1px solid rgba(255,255,255,0.2);
}

.portalText {
  position:fixed;
  top:56px;
  left:50%;
  transform:translateX(-50%);
  color:#0ff;
  font-family:monospace;
  background:rgba(0,15,15,0.5);
  padding:6px 10px;
  border:1px solid rgba(0,255,255,0.25);
  display:none;
}

/* MOBILE CONTROLS */
#stepZone {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 70%;
  height: 40%;
  background: rgba(0,0,0,0.15);
  z-index: 999;
}

#jumpBtn {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: linear-gradient(45deg,#00ffd5,#00aaff);
  color: #000;
  font-size: 22px;
  font-weight: bold;
  border: none;
  z-index: 1000;
}


@media (pointer: fine) {
  #stepZone,
  #jumpBtn {
    display: none !important;
  }
}

</style>
</head>


<body>
id="portalText"></div>


<button id="restartBtn" style="
  display:none;
  position:fixed;
  top:60%;
  left:50%;
  transform:translate(-50%,-50%);
  padding:10px 22px;
  font-size:18px;
  font-family:bold 60px Arial;  
  letter-spacing:2px;                             
  background:linear-gradient(45deg, #ff4444, #ff8855); 
  color:#000000;
  border:none;
  border-radius:8px;
  cursor:pointer;
  text-shadow:0 0 6px #ff7777, 0 0 10px #ff2222;  
  z-index:1000;
  transition:0.2s all;
">
  RESTART
</button>



<!-- MOBILE CONTROLS -->
<div id="stepZone"></div>
<button id="jumpBtn">JUMP</button>


<canvas id="game"></canvas>

<div class="ui">
  <div class="controlsText">
    
    üñ±Ô∏è LEFT CLICK = Left leg ‚Ä¢ RIGHT CLICK = Right leg<br>
    ‚å®Ô∏è SPACE = JUMP<br>
    üì± TAP SLOW/FAST = STEP/RUN<br>
    üîµ JUMP BUTTON = JUMP
  </div>
</div>



<div class="banner" id="banner"></div>
<div class="portalText" id="portalText"></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");


let speedScale = 1;
let lastFrameTime = performance.now();


let gameStarted = false; 
/* ================= ANTI-CHEAT: KILL ON WINDOW SWITCH ================= */
function triggerWindowDeath() {
  if (!dead && !gameWon) { 
    dead = true;
    bgMusic.pause();
    if (typeof deathSound !== 'undefined' && !deathSound.playedOnce) {
      deathSound.currentTime = 0;
      deathSound.play();
      deathSound.playedOnce = true;
    }
  }
}


document.addEventListener("visibilitychange", () => {
  if (document.hidden) triggerWindowDeath();
});

window.addEventListener("blur", triggerWindowDeath);

let mapCompleted = false;


let gameWon = false;

let visitedMaps = [0]; 

let distance = 0;


let score = 0;


/* ================= FOOTSTEP SOUNDS ================= */

const step1 = new Audio("step1.mp3");
const step2 = new Audio("step2.mp3");

step1.volume = 0.15;
step2.volume = 0.15;

let stepToggle = false;



/* ================= SOUNDS ================= */

// jump sound
const jumpSound = new Audio("jump.wav");
jumpSound.volume = 0.5;

// death sound
const deathSound = new Audio("death.wav");
deathSound.volume = 0.3;


let audioUnlocked = false;
function unlockAudio() {
  if (!audioUnlocked) {
    jumpSound.play().then(() => {
      jumpSound.pause();
      jumpSound.currentTime = 0;
    }).catch(()=>{});
    audioUnlocked = true;
  }
}

/* ================= BACKGROUND MUSIC ================= */

const bgMusic = new Audio("bgm.wav");
bgMusic.loop = true;
bgMusic.volume = 0.17;






const DESKTOP_W = 1280;
const DESKTOP_H = 720;

function resize() {
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;

  
  const isMobile = window.innerWidth < 900;

canvas.width = isMobile ? 960 : DESKTOP_W;
canvas.height = isMobile ? 540 : DESKTOP_H;



  const scale = Math.min(
    screenW / DESKTOP_W,
    screenH / DESKTOP_H
  );

  canvas.style.width = DESKTOP_W * scale + "px";
  canvas.style.height = DESKTOP_H * scale + "px";

  canvas.style.position = "absolute";
  canvas.style.left = "50%";
  canvas.style.top = "50%";
  canvas.style.transform = "translate(-50%, -50%)";
}

resize();
window.addEventListener("resize", resize);


/* ================= WORLD ================= */
const groundH = 140;
const fenceX = 40;
const gravity = 0.950;
// ===== SPEED SETTINGS =====
let treadmill = 3.6;    
let groundSpeed = treadmill;
const PORTAL_SPEED_STEP = 0.02857;
const MAX_SPEED =4.2;      
let lastSpeedIncrease = performance.now(); 


/* ================= PLATFORM ================= */
const tileWidth = 100;
let tiles = [];
let spikes = [];
let difficulty = 1;

let spikeInterval = 75; // frames
let spikeSpeed = 1 ;
const MAX_SPIKES = 3;        
const SPIKE_COOLDOWN = 120; 
let spikeCooldownTimer = 0;
let spikeCycleTimer = 0;
let spikesEnabled = true;

const SPIKES_ON_TIME = 30 * 60;
const SPIKES_OFF_TIME = 30 * 60;



function initTiles() {
  tiles = [];
  for (let i = 0; i < Math.ceil(canvas.width / tileWidth) + 2; i++) {
    tiles.push({ x: i * tileWidth });
  }
}
initTiles();

function spawnSpike() {
  const spikeHeight = rand(25, 45);
  spikes.push({
    x: canvas.width + rand(100, 400),
    y: canvas.height - groundH - spikeHeight,
    w: rand(24, 36),
    h: spikeHeight
  });
}



/* ================= SPRITE ================= */
const sheet = new Image();
sheet.src = "V_sprites.png";
let spriteReady = false;
sheet.onload = () => { spriteReady = true; };

const FRAMES = { IDLE:0, LEFT:1, RIGHT:2, RUN:3, JUMP:4 };
let frame = FRAMES.IDLE;


const frameWidths = [280, 270, 270, 380, 280];

let targetHeight = 0;
const player = {
  x: canvas.width * 0.6,
  y: 0,
  vy: 0,
  onGround: true,
  stepTimer: 0,
  lastStep: 0
};
let dead = false;

/* ================= INPUT ================= */
addEventListener("contextmenu", e => e.preventDefault());
addEventListener("mousedown", e => {
  if (gameWon) return;
  if (dead) return;
  playStep();
  const now = performance.now();
  const delta = now - player.lastStep;
  player.lastStep = now;

  if (e.button === 0) {
    frame = (delta < 200) ? FRAMES.RUN : FRAMES.LEFT;
    player.x += 20;
    distance += 20;
    player.stepTimer = 4;
  } else if (e.button === 2) {
    frame = (delta < 200) ? FRAMES.RUN : FRAMES.RIGHT;
    player.x += 20;
    distance += 20;
    player.stepTimer = 4;
  }
});




// ===== MOBILE CONTROLS =====
let nextLegLeft = true;

const stepZone = document.getElementById("stepZone");
const jumpBtn = document.getElementById("jumpBtn");

stepZone.addEventListener("touchstart", e => {
  e.preventDefault();
  if (dead || gameWon) return;
  unlockAudio();

  playStep();

  frame = nextLegLeft ? FRAMES.LEFT : FRAMES.RIGHT;
  nextLegLeft = !nextLegLeft;

  player.x += 20;
  distance += 20;
  player.stepTimer = 4;
}, { passive:false });

jumpBtn.addEventListener("touchstart", e => {
  e.preventDefault();
  if (dead || gameWon) return;

  if (player.onGround) {
    player.vy = -18;
    player.onGround = false;
    frame = FRAMES.JUMP;

    jumpSound.currentTime = 0;
    jumpSound.play();
  }
}, { passive:false });

/*==JUMP(SPACE)==*/
addEventListener("keydown", e => {
  if (e.code === "Space" && player.onGround) {
    unlockAudio();

    player.vy = -18;
    player.onGround = false;
    frame = FRAMES.JUMP;

    jumpSound.currentTime = 0;
    jumpSound.play();
  }
});








/* ================= BACKGROUNDS ================= */


const bgImage = new Image();
bgImage.src = "ice_mountains.png";

const bgSpaceImg = new Image();
bgSpaceImg.src = "space_realistic.png";

const bgDarkFantasyImg = new Image();
bgDarkFantasyImg.src = "dark_fantasy.png";

let bgReady = false;
bgImage.onload = () => { bgReady = true; };


let bgOffset = 0;


function rand(min,max){ return Math.random()*(max-min)+min; }


function drawImageMap() {
  if (!bgImage.complete) return;

  const targetH = canvas.height;
  const scale = targetH / bgImage.height;
  const targetW = bgImage.width * scale;

  let startX = (bgOffset * 0.6) % targetW;
  if (startX > 0) startX -= targetW;

  for (let x = startX; x < canvas.width; x += targetW) {
    ctx.drawImage(
      bgImage,
      0, 0, bgImage.width, bgImage.height,
      x, 0, targetW, targetH
    );
  }
}

function drawSpaceImageMap() {
  if (!bgSpaceImg.complete) return;

  const targetH = canvas.height;
  const scale = targetH / bgSpaceImg.height;
  const targetW = bgSpaceImg.width * scale;

  let startX = (bgOffset * 0.6) % targetW;
  if (startX > 0) startX -= targetW;

  for (let x = startX; x < canvas.width; x += targetW) {
    ctx.drawImage(bgSpaceImg, 0, 0, bgSpaceImg.width, bgSpaceImg.height,
      x, 0, targetW, targetH);
  }
}


function drawDarkFantasyImageMap() {
  if (!bgDarkFantasyImg.complete) return;

  const targetH = canvas.height;
  const scale = targetH / bgDarkFantasyImg.height;
  const targetW = bgDarkFantasyImg.width * scale;

  let startX = (bgOffset * 0.6) % targetW;
  if (startX > 0) startX -= targetW;

  for (let x = startX; x < canvas.width; x += targetW) {
    ctx.drawImage(bgDarkFantasyImg, 0, 0,
      bgDarkFantasyImg.width, bgDarkFantasyImg.height,
      x, 0, targetW, targetH);
  }
}


function drawStars() {
  ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  const seed = (bgOffset*0.2) % canvas.width;
  for (let i=0;i<250;i++){
    const x = (i*37 + seed) % canvas.width;
    const y = (i*91) % canvas.height;
    ctx.fillRect(x, y, 1, 1);
  }
  
  const g = ctx.createRadialGradient(canvas.width*0.7, canvas.height*0.3, 0, canvas.width*0.7, canvas.height*0.3, canvas.width*0.5);
  g.addColorStop(0, "rgba(80,120,255,0.08)");
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function drawRain() {
  // Moody sky
  const sky = ctx.createLinearGradient(0,0,0,canvas.height);
  sky.addColorStop(0,"#1a1a22"); sky.addColorStop(1,"#0d0d12");
  ctx.fillStyle = sky; ctx.fillRect(0,0,canvas.width,canvas.height);
  // Rain streaks
  ctx.strokeStyle = "rgba(180,200,255,0.55)";
  ctx.lineWidth = 1;
  const drift = bgOffset*1.2;
  for (let i=0;i<400;i++){
    const x = (i*19 + drift) % canvas.width;
    const y = (i*53 + drift*2) % canvas.height;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x+2, y+10);
    ctx.stroke();
  }
  
  const haze = ctx.createLinearGradient(0, canvas.height-groundH-120, 0, canvas.height);
  haze.addColorStop(0,"rgba(200,200,255,0.0)");
  haze.addColorStop(1,"rgba(200,200,255,0.15)");
  ctx.fillStyle = haze;
  ctx.fillRect(0, canvas.height-groundH-120, canvas.width, 120);
}

function drawThunderstorm() {
  // Dark stormy sky
  const sky = ctx.createLinearGradient(0,0,0,canvas.height);
  sky.addColorStop(0,"#0a0a0f"); sky.addColorStop(1,"#121218");
  ctx.fillStyle = sky; ctx.fillRect(0,0,canvas.width,canvas.height);
  // Storm clouds bands
  ctx.fillStyle = "rgba(50,50,70,0.7)";
  for (let i=0;i<6;i++){
    const y = (i*60 + (bgOffset*0.3)%60);
    ctx.fillRect(0, y, canvas.width, 40);
  }
  // Rain
  ctx.strokeStyle = "rgba(150,170,220,0.6)";
  const drift = bgOffset*1.4;
  for (let i=0;i<500;i++){
    const x = (i*23 + drift) % canvas.width;
    const y = (i*47 + drift*2) % canvas.height;
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+2, y+12); ctx.stroke();
  }
  //  lightning flash
  if (Math.random() < 0.015) {
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // lightning bolt
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 2;
    const lx = rand(canvas.width*0.2, canvas.width*0.8);
    ctx.beginPath();
    ctx.moveTo(lx, 0);
    ctx.lineTo(lx-20, 100);
    ctx.lineTo(lx+10, 180);
    ctx.lineTo(lx-30, 260);
    ctx.stroke();
  }
}

function drawSunset() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#ff9a3c"); g.addColorStop(0.5,"#c04380"); g.addColorStop(1,"#1b0b30");
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // Silhouette dunes
  ctx.fillStyle = "#2b163e";
  const base = canvas.height - groundH;
  ctx.beginPath();
  ctx.moveTo(0, base);
  for (let x=0; x<=canvas.width; x+=20) {
    const y = base - 20*Math.sin((x+bgOffset*0.3)/120);
    ctx.lineTo(x,y);
  }
  ctx.lineTo(canvas.width, base);
  ctx.closePath(); ctx.fill();
}

function drawAurora() {
  ctx.fillStyle="#000"; ctx.fillRect(0,0,canvas.width,canvas.height);
  for (let i=0;i<3;i++){
    const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    g.addColorStop(0,"rgba(80,255,160,0.08)");
    g.addColorStop(1,"rgba(0,160,255,0.04)");
    ctx.fillStyle = g;
    ctx.save();
    ctx.translate(0, Math.sin((bgOffset+i*50)/100)*40);
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }
  // Sparse stars
  ctx.fillStyle="rgba(255,255,255,0.8)";
  for (let i=0;i<120;i++){
    const x=(i*41 + bgOffset*0.2)%canvas.width;
    const y=(i*79)%canvas.height;
    ctx.fillRect(x,y,1,1);
  }
}

function drawCity() {
  // Night sky
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#0a0a12"); g.addColorStop(1,"#151520");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // Scrolling buildings
  const base = canvas.height - groundH;
  const width = 60;
  for (let i=0;i<Math.ceil(canvas.width/width)+5;i++){
    const x = i*width - (bgOffset % width);
    const h = 120 + 140*Math.abs(Math.sin(i*0.7));
    ctx.fillStyle = "#2c2c3c";
    ctx.fillRect(x, base - h, width - 8, h);
    // windows
    ctx.fillStyle = "rgba(255,230,120,0.7)";
    for (let yy=base-h+10; yy<base-10; yy+=18){
      if (Math.random()<0.3) ctx.fillRect(x+10, yy, 6, 6);
      if (Math.random()<0.3) ctx.fillRect(x+28, yy, 6, 6);
    }
  }
}

function drawForest() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#043d2c"); g.addColorStop(1,"#0d1f14");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // parallax tree rows
  const base = canvas.height - groundH;
  ctx.fillStyle="#0f5a3f";
  for (let i=0;i<20;i++){
    const x = (i*120 - (bgOffset*0.5)%120);
    const h = rand(60,120);
    ctx.beginPath();
    ctx.moveTo(x, base);
    ctx.lineTo(x+10, base - h);
    ctx.lineTo(x+20, base);
    ctx.closePath();
    ctx.fill();
  }
  ctx.fillStyle="#124c34";
  for (let i=0;i<25;i++){
    const x = (i*90 - (bgOffset*0.8)%90);
    const h = rand(40,100);
    ctx.beginPath();
    ctx.moveTo(x, base);
    ctx.lineTo(x+8, base - h);
    ctx.lineTo(x+16, base);
    ctx.closePath();
    ctx.fill();
  }
}

function drawDesert() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#f7d9a6"); g.addColorStop(1,"#c99f61");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  ctx.fillStyle="#b88749";
  ctx.beginPath();
  ctx.moveTo(0, base);
  for (let x=0;x<=canvas.width;x+=10){
    const y = base - 10*Math.sin((x+bgOffset*0.4)/90);
    ctx.lineTo(x,y);
  }
  ctx.lineTo(canvas.width, base);
  ctx.closePath(); ctx.fill();
}

function drawVolcano() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#2a0f0f"); g.addColorStop(1,"#130606");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  // mountain
  ctx.fillStyle="#3b0f10";
  ctx.beginPath();
  ctx.moveTo(canvas.width*0.4, base);
  ctx.lineTo(canvas.width*0.55, base - 160);
  ctx.lineTo(canvas.width*0.7, base);
  ctx.closePath(); ctx.fill();
  // lava glow
  ctx.fillStyle="rgba(255,120,20,0.25)";
  ctx.beginPath();
  ctx.arc(canvas.width*0.55, base - 160, 80, 0, Math.PI*2);
  ctx.fill();
}

function drawSnow() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#bcd3f5"); g.addColorStop(1,"#6f8db5");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // snow drift
  ctx.fillStyle="#e8f2ff";
  for (let i=0;i<200;i++){
    const x = (i*27 + bgOffset*0.3)%canvas.width;
    const y = (i*59)%canvas.height;
    ctx.beginPath(); ctx.arc(x,y,1.5,0,Math.PI*2); ctx.fill();
  }
}

function drawNeonCity() {
  ctx.fillStyle="#01010a"; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  // glowing panels
  for (let i=0;i<12;i++){
    const x = (i*140 - (bgOffset*0.6)%140);
    const h = 140 + 80*Math.sin(i);
    const color = i%2 ? "rgba(255,0,180,0.6)" : "rgba(0,220,255,0.6)";
    ctx.fillStyle = color;
    ctx.fillRect(x, base - h, 90, h);
  }
}

function drawOcean() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#003a6b"); g.addColorStop(1,"#021e36");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // waves
  ctx.strokeStyle="rgba(255,255,255,0.2)";
  for (let y=canvas.height*0.4; y<canvas.height-groundH; y+=18){
    ctx.beginPath();
    for (let x=0; x<=canvas.width; x+=10) {
      const yy = y + 2*Math.sin((x+bgOffset*0.5)/70);
      if (x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();
  }
}

function drawCanyon() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#c96e3d"); g.addColorStop(1,"#5b2d1c");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  ctx.fillStyle="#8a3f23";
  for (let i=0;i<10;i++){
    const x = (i*180 - (bgOffset*0.4)%180);
    const h = 80 + 60*Math.sin(i*0.7);
    ctx.fillRect(x, base - h, 160, h);
  }
}

function drawSavanna() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#f2d27a"); g.addColorStop(1,"#7a6132");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // distant acacia silhouettes
  ctx.fillStyle="#3a2b15";
  const base = canvas.height - groundH;
  for (let i=0;i<8;i++){
    const x = (i*220 - (bgOffset*0.5)%220);
    ctx.fillRect(x, base-40, 6, 40);
    ctx.beginPath(); ctx.arc(x+3, base-45, 18, 0, Math.PI*2); ctx.fill();
  }
}

function drawMarsh() {
  ctx.fillStyle="#1c2430"; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  ctx.fillStyle="rgba(80,120,100,0.5)";
  for (let i=0;i<20;i++){
    const x = (i*140 - (bgOffset*0.5)%140);
    ctx.fillRect(x, base-30, 80, 12);
  }
  // mist
  const mist = ctx.createLinearGradient(0, base-100, 0, base+40);
  mist.addColorStop(0,"rgba(200,220,220,0.0)");
  mist.addColorStop(1,"rgba(200,220,220,0.18)");
  ctx.fillStyle=mist; ctx.fillRect(0, base-100, canvas.width, 140);
}

function drawRuins() {
  ctx.fillStyle="#2e2e2e"; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  ctx.fillStyle="#6b6b6b";
  for (let i=0;i<10;i++){
    const x = (i*160 - (bgOffset*0.5)%160);
    ctx.fillRect(x, base-80, 120, 80);
    ctx.clearRect(x+20, base-65, 20, 20);
    ctx.clearRect(x+60, base-65, 20, 20);
  }
}

function drawHarbor() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#244a7f"); g.addColorStop(1,"#0f213b");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  // cranes
  ctx.strokeStyle="#a3b6c9"; ctx.lineWidth=2;
  for (let i=0;i<6;i++){
    const x = (i*220 - (bgOffset*0.6)%220);
    ctx.beginPath(); ctx.moveTo(x, canvas.height-groundH-120);
    ctx.lineTo(x+40, canvas.height-groundH-160);
    ctx.lineTo(x+60, canvas.height-groundH-120);
    ctx.stroke();
  }
}

function drawTropical() {
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,"#4fd2a4"); g.addColorStop(1,"#1b6b52");
  ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  // palms
  ctx.strokeStyle="#2b3d22"; ctx.lineWidth=3;
  for (let i=0;i<8;i++){
    const x = (i*180 - (bgOffset*0.5)%180);
    ctx.beginPath(); ctx.moveTo(x, base); ctx.lineTo(x+6, base-60); ctx.stroke();
    ctx.fillStyle="#2f7c54";
    for (let a=-Math.PI/3; a<=Math.PI/3; a+=Math.PI/12){
      ctx.beginPath();
      ctx.moveTo(x+6, base-60);
      ctx.lineTo(x+6 + 30*Math.cos(a), base-60 + 30*Math.sin(a));
      ctx.stroke();
    }
  }
}

function drawStarport() {
  ctx.fillStyle="#0c0c12"; ctx.fillRect(0,0,canvas.width,canvas.height);
  const base = canvas.height - groundH;
  // rim buildings
  ctx.fillStyle="#5c6670";
  for (let i=0;i<10;i++){
    const x = (i*160 - (bgOffset*0.6)%160);
    const h = 120 + 60*Math.sin(i*0.4);
    ctx.fillRect(x, base-h, 120, h);
  }
  // runway lights
  ctx.fillStyle="rgba(0,255,255,0.8)";
  for (let i=0;i<canvas.width; i+=100){
    ctx.beginPath(); ctx.arc(i - (bgOffset%100), base-10, 3, 0, Math.PI*2); ctx.fill();
  }
}

/* 22 maps total: 3 image + 19 (Can you beat these maps ? ) */
const MAPS = [
  { name:"Ice mountains ", draw: drawImageMap },
  { name:"Deep space ", draw: drawSpaceImageMap },
  { name:"Dark fantasy realm ", draw: drawDarkFantasyImageMap },
  { name:"Stars", draw: drawStars },
  { name:"Rainy city", draw: drawRain },
  { name:"Thunderstorm coast", draw: drawThunderstorm },
  { name:"Sunset dunes", draw: drawSunset },
  { name:"Aurora night", draw: drawAurora },
  { name:"Urban skyline", draw: drawCity },
  { name:"Pine forest", draw: drawForest },
  { name:"Desert sands", draw: drawDesert },
  { name:"Volcanic plains", draw: drawVolcano },
  { name:"Snow valley", draw: drawSnow },
  { name:"Neon cyber city", draw: drawNeonCity },
  { name:"Open ocean", draw: drawOcean },
  { name:"Rocky canyon", draw: drawCanyon },
  { name:"Golden savanna", draw: drawSavanna },
  { name:"Foggy marsh", draw: drawMarsh },
  { name:"Temple ruins", draw: drawRuins },
  { name:"Harbor dawn", draw: drawHarbor },
  { name:"Tropical coast", draw: drawTropical },
  { name:"Starport rim", draw: drawStarport },
  
];

let currentMapIndex = 0;

/* ================= PORTAL (DOOR) ================= */
const portal = {
  active: false,
  x: 0,
  y: 0,
  w: 70,
  h: 140,
  targetIndex: 0,
  lastSpawnTime: performance.now() + 10000, 
  spawnInterval: 10000
};

const portalTextEl = document.getElementById("portalText");
const bannerEl = document.getElementById("banner");

const restartBtn = document.getElementById("restartBtn");
restartBtn.addEventListener("click", () => {
  hideRestartButton();
  resetGame();
});



function showRestartButton() {
  restartBtn.style.display = "block";
}

function hideRestartButton() {
  restartBtn.style.display = "none";
}


function spawnPortal() {
  const groundBaseline = canvas.height - groundH;
  portal.x = canvas.width - 200;
  portal.y = groundBaseline - portal.h;
  portal.active = true;

  
  const options = MAPS.map((_, i) => i).filter(i => !visitedMaps.includes(i));
  
  if (options.length === 0) {
    // all maps visited, stop spawning portals
    portal.active = false;
    portalTextEl.style.display = "none";
    return;
  }

  portal.targetIndex = options[Math.floor(Math.random() * options.length)];
  portalTextEl.style.display = "block";
  portalTextEl.textContent = `Portal open ‚Üí ${MAPS[portal.targetIndex].name}`;
}


function despawnPortal() {
  portal.active = false;
  portalTextEl.style.display = "none";
  portal.lastSpawnTime = performance.now() + portal.spawnInterval; 
}

addEventListener("mousedown", e => {
  if (gameWon) return;
  
difficulty = 1;
spikeSpeed = 2;
spikeInterval = 90;

if (dead || gameWon) return; 


});


addEventListener("click", () => {
  if (bgMusic.paused) {
    bgMusic.play().catch(() => {});
  }
}, { once: true });



/* ================= LOOPING ================= */



function drawBackground() {
  bgOffset += treadmill * speedScale;

  MAPS[currentMapIndex].draw();
}


function resetGame() {
  dead = false;
  score = 0;
  distance = 0;
  treadmill = 3.6;
  visitedMaps = [0];
  gameWon = false;
  groundSpeed = treadmill;                  
lastSpeedIncrease = performance.now(); 
hideRestartButton();

  bgMusic.currentTime = 0;
  bgMusic.play().catch(()=>{});

  // player
  player.x = canvas.width * 0.6;
  player.y = 0;
  player.vy = 0;
  player.onGround = true;
  frame = FRAMES.IDLE;

  // spikes
  spikes.length = 0;
  spikeCooldownTimer = 0;
  spikeTimer = 0;
  spikeSpeed = 1;   // base spike speed
  difficulty = 1;

  // world
  bgOffset = 0;
  currentMapIndex = 0;
  initTiles();

  // portal
  portal.active = false;
  portal.lastSpawnTime = performance.now() + portal.spawnInterval;
  portalTextEl.style.display = "none";
  bannerEl.textContent = "";

  // distance / timer
  distance = 0;
  gameStartTime = performance.now();
}

function playStep() {
  const sound = (stepToggle ? step1 : step2).cloneNode();
  stepToggle = !stepToggle;
  sound.volume = 0.4;
  sound.play();
}





function loop(){
  const now = performance.now();
  speedScale = (now - lastFrameTime) / 16.666;
  lastFrameTime = now;

  if (speedScale > 2) speedScale = 2; // safety clamp

  

  


  if (gameWon) {
  bgMusic.pause();

  ctx.fillStyle = "rgba(0,0,0,0.65)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#00ffcc";
  ctx.font = "bold 54px Arial";
  ctx.textAlign = "center";
  ctx.fillText(
    "YOU ARE A LEGEND",
    canvas.width / 2,
    canvas.height / 2 - 40
  );

  ctx.font = "28px Arial";
  ctx.fillStyle = "#ffffff";
  ctx.fillText(
    "ALL MAPS COMPLETED",
    canvas.width / 2,
    canvas.height / 2 + 10
  );

 
  requestAnimationFrame(loop);
  return; 
}

 



score = Math.floor(distance / 50);


  // ===== Play death sound when player dies =====
if (dead && !deathSound.playedOnce) {
  deathSound.currentTime = 0;
  deathSound.play();
  deathSound.playedOnce = true; 
}

if (dead) bgMusic.pause();  




if (!dead) {
  deathSound.playedOnce = false;
}



  // spike on/off cycle
spikeCycleTimer++;

if (spikesEnabled && spikeCycleTimer >= SPIKES_ON_TIME) {
  spikesEnabled = false;
  spikeCycleTimer = 0;
}

if (!spikesEnabled && spikeCycleTimer >= SPIKES_OFF_TIME) {
  spikesEnabled = true;
  spikeCycleTimer = 0;
}


  ctx.clearRect(0,0,canvas.width,canvas.height);


  /* ---- BACKGROUND (20 maps) ---- */
  drawBackground();

  /* ---- PLATFORM UPDATE ---- */
  for (let tile of tiles) {
    tile.x -= groundSpeed * speedScale;

    if (tile.x + tileWidth < 0) {
      tile.x = Math.max(...tiles.map(t => t.x)) + tileWidth;
    }
  }
if (dead) {
    // Dark overlay
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.textAlign = "center";
    
    // Header
    ctx.fillStyle = "#ff4444";
    ctx.font = "bold 60px Arial";
    ctx.fillText("YOU DIED", canvas.width / 2, canvas.height / 2 - 100);

    // Score
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 36px Arial";
    ctx.fillText("SCORE: " + Math.floor(score), canvas.width / 2, canvas.height / 2 - 40);

    // Map Progress - Cleanly separated
    ctx.fillStyle = "#00ffcc";
    ctx.font = "bold 28px Arial";
    ctx.fillText(
      `Maps Covered: ${visitedMaps.length} / ${MAPS.length}`,
      canvas.width / 2,
      canvas.height / 2 + 20
    );

    // SHOW BUTTON INSTEAD OF TEXT
showRestartButton();


    requestAnimationFrame(loop);
    return;
  }

  /* ---- PLATFORM DRAW ---- */
  const groundBaseline = canvas.height - groundH;
  ctx.fillStyle = "#2d334a";
  for (let tile of tiles) {
    ctx.fillRect(tile.x, groundBaseline, tileWidth, groundH);
  }


// ===== DRAW SCORE =====
ctx.fillStyle = "#ffffff";
ctx.font = "30px Arial";
ctx.textAlign = "left";
ctx.fillText("Score: " + Math.floor(score), 60, 30);



  // ---- SPIKES UPDATE ----
spikeCooldownTimer++;

if (
  spikesEnabled &&    
  spikeCooldownTimer >= SPIKE_COOLDOWN &&
  spikes.length < MAX_SPIKES &&
  !dead
) {
  spawnSpike();
  spikeCooldownTimer = 0;
}




spikeInterval = Math.max(50, 90 - difficulty * 10);


// Increase difficulty slowly
difficulty += 0.0005;
spikeSpeed = 2 + difficulty * 1.5;
spikeInterval = Math.max(35, 90 - difficulty * 10);

ctx.fillStyle = "gray";
for (let i = spikes.length - 1; i >= 0; i--) {
  const s = spikes[i];
  s.x -= (spikeSpeed + treadmill) * speedScale;


  ctx.beginPath();
  ctx.moveTo(s.x, s.y + s.h);
  ctx.lineTo(s.x + s.w / 2, s.y);
  ctx.lineTo(s.x + s.w, s.y + s.h);
  ctx.closePath();
  ctx.fill();

  if (s.x + s.w < 0) {
    spikes.splice(i, 1);
  }
}




  /* ---- SPRITE POSITIONING ---- */
  if (spriteReady && targetHeight === 0) {
    targetHeight = (canvas.height / 6) * 3;
    player.y = groundBaseline - targetHeight;
  }

  if (!dead) {
    player.x -= treadmill * speedScale;
distance += treadmill * speedScale;

     score = Math.floor(distance / 5); 

    player.vy += gravity * speedScale;
player.y += player.vy * speedScale;


    const groundY = groundBaseline - targetHeight + 160; 
    if (player.y >= groundY) {
      player.y = groundY;
      player.vy = 0;
      player.onGround = true;
      if (player.stepTimer === 0) frame = FRAMES.IDLE;
    }

    if (player.stepTimer > 0) {
      player.stepTimer--;
      if (player.stepTimer === 0 && player.onGround) frame = FRAMES.IDLE;
    }

    // ===== Death checks =====
    if (player.x < fenceX + 10) dead = true; // red fence
    const blueFenceX = canvas.width - 50;
    if (player.x + 10 > blueFenceX) dead = true; // blue fence

   for (let i = spikes.length - 1; i >= 0; i--) {
  const s = spikes[i];
  

  if (!dead) {
  const feetMargin = 35;
  const playerFeet = player.y + targetHeight - feetMargin;

  if (
    player.onGround &&
    player.x + 30 >= s.x &&
    player.x <= s.x + s.w &&
    playerFeet >= s.y
  ) {
    dead = true;
    break;
  }
}

  
  
}


  }


  /* ===== RED FENCE ===== */
  ctx.fillStyle="#900";
  for (let y=0; y<canvas.height; y+=20) ctx.fillRect(fenceX, y, 10, 10);

  /* ===== BLUE FENCE ===== */
  ctx.fillStyle="#009";
  for (let y=0; y<canvas.height; y+=20) ctx.fillRect(canvas.width - 50, y, 10, 10);

  /* ---- PORTAL TIMER / SPAWN ---- */
  
  if (!portal.active && now >= portal.lastSpawnTime) {
    spawnPortal();
  }

  /* ---- PORTAL DRAW ---- */
  if (portal.active) {
    
   portal.x -= treadmill * speedScale;


    // Portal body
    const grd = ctx.createLinearGradient(portal.x, portal.y, portal.x+portal.w, portal.y+portal.h);
    grd.addColorStop(0, "rgba(0,200,255,0.6)");
    grd.addColorStop(1, "rgba(150,0,255,0.6)");
    ctx.fillStyle = grd;
    ctx.fillRect(portal.x, portal.y, portal.w, portal.h);

    // Portal border
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 3;
    ctx.strokeRect(portal.x, portal.y, portal.w, portal.h);

    
    const frameHeight = sheet.height || targetHeight;
    let xOffset = 0; for (let i = 0; i < frame; i++) xOffset += frameWidths[i];
    const fw = frameWidths[frame] || frameWidths[0];
    const aspect = fw / frameHeight;
    const targetWidth = targetHeight * aspect;

    const playerBox = { x: player.x, y: player.y, w: targetWidth, h: targetHeight };
    const portalBox = { x: portal.x, y: portal.y, w: portal.w, h: portal.h };
    const overlap = !(playerBox.x + playerBox.w < portalBox.x ||
                      playerBox.x > portalBox.x + portalBox.w ||
                      playerBox.y + playerBox.h < portalBox.y ||
                      playerBox.y > portalBox.y + portalBox.h);

    if (overlap) {
      
      currentMapIndex = portal.targetIndex;

      treadmill += PORTAL_SPEED_STEP;  
      if (treadmill > MAX_SPEED) treadmill = MAX_SPEED;  
      groundSpeed = treadmill;

      if (!visitedMaps.includes(currentMapIndex)) {
          visitedMaps.push(currentMapIndex);
      }

      bannerEl.textContent = `Warped to: ${MAPS[currentMapIndex].name}`;
      despawnPortal(); 
      bgOffset = 0; 

      if (visitedMaps.length >= MAPS.length) {
        gameWon = true;
      }
    }

   
    if (portal.x + portal.w < 0) {
      despawnPortal();
      portalTextEl.style.display = "none";
    }
  } else {
    
    bannerEl.textContent = `Current map: ${MAPS[currentMapIndex].name}`;
  }

  if (spriteReady) {
    const frameHeight = sheet.height;
    let xOffset = 0;
    for (let i = 0; i < frame; i++) xOffset += frameWidths[i];
    const fw = frameWidths[frame];
    const aspect = fw / frameHeight;
    const targetWidth = targetHeight * aspect;

    ctx.drawImage(sheet, xOffset, 0, fw, frameHeight, player.x, player.y, targetWidth, targetHeight);
  }

  


  requestAnimationFrame(loop);
}

  loop();

</script> 
</body>
</html>
